#! /usr/bin/env python
# -*- coding: utf-8 -*-
# Задача 1: сравнение предложений
#
# Дан набор предложений, скопированных с Википедии. Каждое из них имеет "кошачью тему" в одном из трех смыслов:
#
#     кошки (животные)
#     UNIX-утилита cat для вывода содержимого файлов
#     версии операционной системы OS X, названные в честь семейства кошачьих
#
# Ваша задача — найти два предложения, которые ближе всего по смыслу к расположенному в самой первой строке. В качестве меры близости по смыслу мы будем использовать косинусное расстояние.
# sentences.txt
#
# Выполните следующие шаги:
#
#     1.Скачайте файл с предложениями (sentences.txt).
#     2.Каждая строка в файле соответствует одному предложению.
#       Считайте их, приведите каждую к нижнему регистру с помощью строковой функции lower().
#     3.Произведите токенизацию, то есть разбиение текстов на слова.
#       Для этого можно воспользоваться регулярным выражением, которое считает разделителем
#       любой символ, не являющийся буквой: re.split('[^a-z]', t). Не забудьте удалить пустые слова после разделения.
#     4.Составьте список всех слов, встречающихся в предложениях. Сопоставьте каждому слову индекс
#       от нуля до (d - 1), где d — число различных слов в предложениях. Для этого удобно воспользоваться структурой dict.
#     Создайте матрицу размера n * d, где n — число предложений. Заполните ее: элемент с индексом
# (i, j) в этой матрице должен быть равен количеству вхождений j-го слова в i-е предложение.
# У вас должна получиться матрица размера 22 * 254.
#     Найдите косинусное расстояние от предложения в самой первой строке
# (In comparison to dogs, cats have not undergone...) до всех остальных с помощью
# функции scipy.spatial.distance.cosine. Какие номера у двух предложений, ближайших к нему по этому расстоянию (строки нумеруются с нуля)? Эти два числа и будут ответами на задание.
#     Запишите полученные числа в файл, разделив пробелом. Обратите внимание,
# что файл должен состоять из одной строки, в конце которой не должно быть переноса.
# Пример файла с решением вы можете найти в конце задания (submission-1.txt).
#     Совпадают ли ближайшие два предложения по тематике с первым? Совпадают ли
# тематики у следующих по близости предложений?

#regular expression
import re
#arrays
import numpy as np
from scipy import spatial as sp


#     1.Скачайте файл с предложениями (sentences.txt).
#     2.Каждая строка в файле соответствует одному предложению.
#       Считайте их, приведите каждую к нижнему регистру с помощью строковой функции lower().
file_obj = open("sentences.txt", 'r')
# data_list = file_obj.readlines()
# print file_obj.read()
#     3.Произведите токенизацию, то есть разбиение текстов на слова.
#       Для этого можно воспользоваться регулярным выражением, которое считает разделителем
#       любой символ, не являющийся буквой: re.split('[^a-z]', t). Не забудьте удалить пустые слова после разделения.
data_list = []
words = []
for x in file_obj:
    y = np.array(
        filter(None,
               re.split('[^a-z]', x.strip().lower())
               )
    )
    # y = y[y != '']
    data_list.append(y)
    words = np.concatenate([words, y], axis=0)

words2 = np.unique(words)
words = list(set(words))

print len(words)
print len(words2)
print len(data_list)

#     4.Составьте список всех слов, встречающихся в предложениях. Сопоставьте каждому слову индекс
#       от нуля до (d - 1), где d — число различных слов в предложениях. Для этого удобно воспользоваться структурой dict.

dict = {}
for idx, item in enumerate(words):
    dict[idx] = item
print dict

matrix = np.zeros((len(data_list), len(words)))

for n in range(len(data_list)):
    for m in range(len(words)):
        matrix[n,m] = int(list(data_list[n]).count(dict[m]))
print matrix

dict = {}
for n in range(len(data_list)):
    result2 = round((sp.distance.cosine(matrix[0],matrix[n])), 2)
    # result.append(result2)
    dict[n] = result2
print dict

# for key in sorted(dict.iterkeys()):
#     print "%s: %s" % (key, dict[key])

for key, value in sorted(dict.iteritems(), key=lambda (k,v): (v,k)):
    print "%s: %s" % (key, value)