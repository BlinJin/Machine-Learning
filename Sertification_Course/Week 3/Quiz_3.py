#  -*- coding: utf-8 -*-
# Задача 3. Минимизация негладкой функции
#
#     1.Теперь рассмотрим функцию h(x) = int(f(x)) на том же отрезке [1, 30],
#       т.е. теперь каждое значение f(x) приводится к типу int и функция принимает только целые значения.
#     2.Такая функция будет негладкой и даже разрывной, а ее график будет иметь ступенчатый вид.
#       Убедитесь в этом, построив график h(x) с помощью matplotlib.
#     3.Попробуйте найти минимум функции h(x) с помощью BFGS, взяв в качестве начального приближения x=30.
#       Получившееся значение функции – ваш первый ответ в этой задаче.
#     4.Теперь попробуйте найти минимум h(x) на отрезке [1, 30] с помощью дифференциальной эволюции.
#       Значение функции h(x) в точке минимума – это ваш второй ответ в этом задании. Запишите его через пробел после предыдущего.
#     5.Обратите внимание на то, что полученные ответы различаются.
#       Это ожидаемый результат, ведь BFGS использует градиент (в одномерном случае – производную)
#       и явно не пригоден для минимизации рассмотренной нами разрывной функции. Попробуйте понять,
#       почему минимум, найденный BFGS, именно такой (возможно в этом вам поможет выбор разных начальных приближений).
#     6.Выполнив это задание, вы увидели на практике, чем поиск минимума функции
#       отличается от глобальной оптимизации, и когда может быть полезно применить вместо
#       градиентного метода оптимизации метод, не использующий градиент. Кроме того, вы попрактиковались в
#       использовании библиотеки SciPy для решения оптимизационных задач, и теперь знаете, насколько это просто и удобно.


import numpy as np
import matplotlib.pylab as plt
from scipy.optimize import minimize
from scipy.optimize import differential_evolution

# f(x) = sin(x / 5) * exp(x / 10) + 5 * exp(-x / 2)
#     1.Теперь рассмотрим функцию h(x) = int(f(x)) на том же отрезке [1, 30],
#       т.е. теперь каждое значение f(x) приводится к типу int и функция принимает только целые значения.
def functQuiz(x):
    f = np.sin(x / 5.) * np.exp(x /10.) + 5 * np.exp(-x /2.)
    return int(f)

xPoints = np.arange(1, 30, 0.1)
fx = functQuiz
yPoints = map(fx, xPoints)
plt.plot(xPoints, yPoints)

#     3.Попробуйте найти минимум функции h(x) с помощью BFGS, взяв в качестве начального приближения x=30.
#       Получившееся значение функции – ваш первый ответ в этой задаче.
x0 = 23
k = minimize(fx, x0, method='BFGS')
print 'BFGS - ', x0
print k
print '------------------'

# BFGS -  30
 #      fun: -5
 # hess_inv: array([[1]])
 #      jac: array([ 0.])
 #  message: 'Optimization terminated successfully.'
 #     nfev: 3
 #      nit: 0
 #     njev: 1
 #   status: 0
 #  success: True
 #        x: array([ 30.])


#     4.Теперь попробуйте найти минимум h(x) на отрезке [1, 30] с помощью дифференциальной эволюции.
#       Значение функции h(x) в точке минимума – это ваш второй ответ в этом задании. Запишите его через пробел после предыдущего.
result = differential_evolution(fx, [(1,30)])
print 'differential evolution - '
print result

plt.show()